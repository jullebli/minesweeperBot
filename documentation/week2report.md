# Week 2 report

Hours used this week: 14,5

Last week I made FirstBot-class that uses two algorithms to solve a minesweeper game. If a square has been opened, it has a number (there is that amount of mines in it's neighbouring squares) and if it has only the same amount of neighbouring squares as it's number then all neighbouring squares are flagged one by one. This "rule" was easy to come by since it is the most obvious. I use it when I'm playing minesweeper. So the bot places flags. The second "rule" is that if a numbered square has the number's amount of flags in it's neighbouring squares then all the other unopened unflagged neighbouring squares are safe and the bot opens those one by one. Sometimes neither of the rules apply and then the bot chooses randomly an unopened unflagged square and opens it. Now I need an algorithm that deals with these cases. Because there are different probabilities for each unopened square to have a mine in it. I need an algorithm that calculates those probalities according to the numbered neighbouring squares. And picks the square with the lowest probability of being a mine. 

I started this week with going through some sources about minesweeper solving algorithms. I found a post by Luckytoilet on "Lucky's notes" website (https://luckytoilet.wordpress.com/2012/12/23/2125/). It had good points about creating a solver. The solver won the minesweeper with 50% success rate. I would like to get a better success rate but according to the comments it is not easy since many had a success rate lower than Luckytoilet's. Lucky toilet gives the hint that if there are not so many unopened squares left then the recursion should be done to all unopened squares. And I guess it helps if you know the total amount of mines in this case.

I searched for more sources. I found from year 2015 a Harvard College Bachelor's thesis paper by Becerra, David J. titled Algorithmic Approaches to Playing Minesweeper (https://dash.harvard.edu/bitstream/handle/1/14398552/BECERRA-SENIORTHESIS-2015.pdf?sequence=1). This thesis proved that it is better to start the game from corners. I need to test that when I have the algorithm ready. Backtracking search and coupled subsets CSP (constraint satisfaction problem) were mentioned. Backtracking is used to find all the possible solutions for mine locations that follow the constraints. Constraints being the numbers in the neighbouring squares. I also think that a constraint could be the total mine amount.

I searched some other sources that were similar. I found an interesting source but I can't make a solution that uses matrices since I'm not familiar with linear algebra. Now I think I have finally done enough research to make the project specification document.

I have been struggling with this project. I'm not really sure what I need to do and how to use the material that has been presented as a base for making minesweeper solvers. I asked the teacher by email and got help. He recommended the Harvard thesis that I already found. The solution I had seems to be too slow since it allways calculates the same things. So I will change my solution to follow the algorithm in the Harvard thesis.

I learned this week about suitable algorithms for making a minesweeper solver. I learned more about coding by reading other's code and their explanations about them. I learned some ways to make the algorithm faster (coupled subsets) and about finging bugs in my code. I learned more about grable projects. I have only used Maven so far.

Next I need to code the CSP algorithm and make some tests. And fix SecondBot, it isn't working how it should. It keeps opening random squares when there are safe options left. FirstBot functions how it should.
